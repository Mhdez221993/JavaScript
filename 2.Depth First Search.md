# Depth First Search

#### Depth First Search Template
```js
function dfs(root, target) {
    if (!root) return null;
    if (root.val == target) return root;
    left = dfs(root.left);
    if (left != null) return left;
    right = dfs(root.right);
    return right;
}
```

#### Let's look at a simple problem of searching for a node in a binary tree whose value is equal to target.
```js
function dfs(root, target) {
    if (!root) return null;
    if (root.val === target) return root;
    // return non-null return value from the recursive calls
    const left = dfs(root.left, target);
    if (left != null) return left;
    const right = dfs(root.right, target);
    // at this point, we know left is null, and right could be null or non-null
    // we return right child's recursive call result directly because
    // - if it's non-null we should return it
    // - if it's null, then both left and right are null, we want to return null
    return right;
}
```

#### Max depth of a binary tree
Max depth of a binary tree is the longest root-to-leaf path.
```js
class Node {
    constructor(val, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

function treeMaxDepth(root) {
    return !root ? 0 : dfs(root) -1;
}

function dfs(root) {
    if(!root) return 0;

    return Math.max(dfs(root.left), dfs(root.right)) + 1;
}
```