# Backtracking

#### Backtracking Templates, Backtracking == DFS on a tree
```js
function dfs(startIndex, path, res, [...additional states]) {
    if (isLeaf(path)) {
        res.push(new Array(path));
        return;
    }
    for (const edge of getEdges(startIndex, [...additional states])) {
        path.push(edge);
        if (...additionl statees) update(...additional states)
        dfs(startIndex + edge.length, path, res, [...addtional states]);
        path.pop();
        // revert(...additional states) if necessary, e.g. permutations
    }
}
```

#### DFS with States
Given a ternary tree (each node of the tree has at most three children), find all root-to-leaf paths.
```js
class Node {
    constructor(val, children = []) {
        this.val = val;
        this.children = children;
    }
}

function ternaryTreePaths(root) {
      let path = [];
      dfs(root, [], path);
      return path;
}

function dfs(root, res, path) {
  res.push(root.val);

  for (let node of root.children) {
    if (node.children.length === 0) {
      res.push(node.val);
      path.push(res.join("->"));
      res.pop();
      continue;
    }

    dfs(node, res, path);
    res.pop();
  }
}
```

#### Find all n-letter words composed by 'a' and 'b', return them in a list of strings in lexicographical order.
Input: 2
<br />
Output: ["aa", "ab", "ba", "bb"]

```js
function letterCombination(n) {
  let res = [];

  function dfs(path) {
    if (path.length === n) {
      res.push(path.join(""));
      return;
    }

    for (let char of "ab") {
      path.push(char);
      dfs(path);
      path.pop();
    }
  }

  dfs([]);
  return res;
}
```