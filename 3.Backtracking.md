# Backtracking

#### Backtracking Templates, Backtracking == DFS on a tree
```js
function dfs(startIndex, path, res, [...additional states]) {
    if (isLeaf(path)) {
        res.push(new Array(path));
        return;
    }
    for (const edge of getEdges(startIndex, [...additional states])) {
        path.push(edge);
        if (...additionl statees) update(...additional states)
        dfs(startIndex + edge.length, path, res, [...addtional states]);
        path.pop();
        // revert(...additional states) if necessary, e.g. permutations
    }
}
```

#### DFS with States
Given a ternary tree (each node of the tree has at most three children), find all root-to-leaf paths.
```js
class Node {
    constructor(val, children = []) {
        this.val = val;
        this.children = children;
    }
}

function ternaryTreePaths(root) {
      let path = [];
      dfs(root, [], path);
      return path;
}

function dfs(root, res, path) {
  res.push(root.val);

  for (let node of root.children) {
    if (node.children.length === 0) {
      res.push(node.val);
      path.push(res.join("->"));
      res.pop();
      continue;
    }

    dfs(node, res, path);
    res.pop();
  }
}
```

#### Find all n-letter words composed by 'a' and 'b', return them in a list of strings in lexicographical order.
Input: 2
<br />
Output: ["aa", "ab", "ba", "bb"]

```js
function letterCombination(n) {
  let res = [];

  function dfs(path) {
    if (path.length === n) {
      res.push(path.join(""));
      return;
    }

    for (let char of "ab") {
      path.push(char);
      dfs(path);
      path.pop();
    }
  }

  dfs([]);
  return res;
}
```

#### Generate All Letter Combinations from a Phone Number
Input: "56"
<br />
Output:["jm","jn","jo","km","kn","ko","lm","ln","lo"]

```js
function letterCombinationsOfPhoneNumber(digits) {
    let res = [];
    dfs(digits, 0, [], res);
    return res;
}

function dfs(digits, i, path, res) {
    if(i === digits.length) {
        res.push(path.join(''));
        return;
    }

    for(const char of KEYBOARD[digits[i]]) {
        path.push(char);
        dfs(digits, i+1, path, res);
        path.pop();
    }
}

const KEYBOARD = {
  '2': 'abc',
  '3': 'def',
  '4': 'ghi',
  '5': 'jkl',
  '6': 'mno',
  '7': 'pqrs',
  '8': 'tuv',
  '9': 'wxyz',
};
```

#### Backtracking with Pruning Template
```js
function dfs(startIndex, path) {
  if (isLeaf(startIndex)) {
    report(path);
    return;
  }

  const edges = getEdges(startIndex);
  for (const edge of edges) {
    // prune if needed
    if (!isValid(edge)) {
      continue;
    }

    path.push(edge);
    // increment startIndex
    dfs(startIndex + edge.length, path);
    path.pop();
  }
}
```

#### Partitioning A String Into Palindromes
Given a string s, partition s such that every substring of the partition is a palindrome.
<br />
Input: aab
<br />
Output:
  [
  ["aa","b"],
  ["a","a","b"]
  ]

```js
function partition(s) {
  let res = [];
  dfs(s, 0, [], res);
  return res;
}

function dfs(s, start, path, res) {
  if (start === s.length) {
    res.push([...path]);
    return;
  }

  for (let end = start + 1; end <= s.length; end++) {
    const prefix = s.substring(start, end);

    if (isPalindrome(prefix)) {
      path.push(prefix);
      dfs(s, end, path, res);
      path.pop();
    }
  }
}

function isPalindrome(word) {
  let l = 0,
    r = word.length - 1;
  while (l < r) {
    if (word.charAt(l) != word.charAt(r)) return false;
    l++;
    r--;
  }
  return true;
}
```

#### Generate All Valid Parentheses
Given an integer n, generate all strings with n matching parentheses.
<br />
n = 2
<br />
Output: (()) ()()

```js
function generateParentheses(n) {
    let res = [];

    function dfs(index, path, start, end) {
        if(index === n*2) {
            res.push(path.join(""));
            return;
        }

       if(start < n) {
           path.push('(');
           dfs(index+1, path, start+1, end);
           path.pop();
       }

       if(end < start) {
           path.push(')');
           dfs(index+1, path, start, end+1);
           path.pop();
       }
    }

    dfs(0, [], 0, 0);
    return res;
}
```

```js
function generateParentheses(n) {
  const dfs = (path, openCount, closeCount, res) => {
    if (path.length === 2 * n) {
      res.push(path.join(''));
      return;
    }

    for (const parenthesis of ['(', ')']) {
      if (parenthesis === '(' && openCount >= n) {
        continue;
      }
      if (parenthesis === ')' && closeCount >= openCount) {
        continue;
      }

      path.push(parenthesis);
      if (parenthesis === '(') {
        openCount++;
      } else {
        closeCount++;
      }

      dfs(path, openCount, closeCount, res);

      // reverting the state
      if (parenthesis === '(') {
        openCount--;
      } else {
        closeCount--;
      }
      path.pop();
    }
  };

  const ans = [];
  dfs([], 0, 0, ans);
  return ans;
}
```

#### General All Permutations
Given a string of unique letters, find all of its distinct permutations.
```js
function permutations(letters) {
    let res = [];
    let mySet = new Set();

    function dfs(path) {
        if(path.length === letters.length) {
            res.push(path.join(''));
            return;
        }

        for(let char of letters) {
            if(!mySet.has(char)) {
                mySet.add(char);
                path.push(char);
                dfs(path);
                path.pop();
                mySet.delete(char);
            }
        }
    }

    dfs([]);
    return res;
}
```